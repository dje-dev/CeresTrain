#region License notice

/*
  This file is part of the CeresTrain project at https://github.com/dje-dev/cerestrain.
  Copyright (C) 2023- by David Elliott and the CeresTrain Authors.

  Ceres is free software under the terms of the GNU General Public License v3.0.
  You should have received a copy of the GNU General Public License
  along with CeresTrain. If not, see <http://www.gnu.org/licenses/>.
*/

#endregion

#region Using directives

using System;

using Ceres.Chess.EncodedPositions;
using Ceres.Base.Benchmarking;

#endregion

namespace CeresTrain.TrainingDataGenerator
{
  /// <summary>
  /// Test driver to scan and compare two TAR files,
  /// one from the original LC0 data, and the other generated by the rewriter,
  /// to confirm that TAR files generated by the rewriter are equivalent to the original TAR.
  /// </summary>
  public static class EncodedTrainingPositionRewriterTest
  {
    /// <summary>
    /// Testing method to confirm that the TAR files are identical
    /// e.g. to compare original TAR files with TAR files rewritten by Ceres.
    /// 
    /// Also tests EncodedTrainingPositionGameReader.
    /// 
    /// </summary>
    /// <param name="correctFN"></param>
    /// <param name="testFN"></param>
    /// <param name="scanTestOnly">if true, no verification takes place but only scanning of test all positions in test file</param>
    /// <exception cref="Exception"></exception>
    public static void VerifyTARsSame(string correctFN, string testFN, bool scanTestOnly)
    {
      long posCount = 0;
      long gameCount = 0;

      using (new TimingBlock("read"))
      {
        var correct = EncodedTrainingPositionReaderTAREngine.EnumerateGames(correctFN, filterOutFRCGames: false).GetEnumerator();
        var test = EncodedTrainingPositionReaderTAREngine.EnumerateGames(testFN, filterOutFRCGames: false).GetEnumerator();
        var testGameReader = EncodedTrainingPositionReader.EnumerateGames(testFN, filterOutFRCGames: false).GetEnumerator();

        while (test.MoveNext())
        {
          Span<EncodedTrainingPosition> positionTest = test.Current.Span;

          if (scanTestOnly)
          {
            continue;
          }

          testGameReader.MoveNext();
          EncodedTrainingPositionGame testGame = testGameReader.Current;


          correct.MoveNext();
          Span<EncodedTrainingPosition> positionCorrect = correct.Current.Span;

          posCount += positionCorrect.Length;
          gameCount++;

          //if (zz % 1000 == 0) 
          //Console.WriteLine("rewrite pos count " + positionCorrect.Length + "/" + positionTest.Length + ", games " + gameCount);

          if (positionTest.Length != positionCorrect.Length)
          {
            throw new Exception("Wrong position count");
          }

          static void CheckBoard(in EncodedPositionWithHistory pos1, in EncodedPositionWithHistory pos2)
          {
            if (pos1.BoardsHistory.History_0.TheirBishops
             != pos2.BoardsHistory.History_0.TheirBishops)
            {
              throw new Exception("Positions different  " + pos1.FinalPosition.FEN + " "
                                                          + pos2.FinalPosition.FEN);
            }
          }

          // Test an item from the training miscellaneous info for equality.
          int visitsCorrect = positionCorrect[0].PositionWithBoards.MiscInfo.InfoTraining.NumVisits;
          int visitsTest = positionTest[0].PositionWithBoards.MiscInfo.InfoTraining.NumVisits;
          if (visitsTest != visitsCorrect) throw new Exception("NumVisitsMismatch in Test");
          int visitsTestGame = testGame.PositionTrainingInfoAtIndex(0).NumVisits;
          if (visitsTestGame != visitsCorrect) throw new Exception("NumVisitsMismatch in TestGame");

          int correctPlayedIndex = positionCorrect[0].PositionWithBoards.MiscInfo.InfoTraining.PlayedIndex;
          if (correctPlayedIndex != testGame.PositionTrainingInfoAtIndex(0).PlayedIndex)
          {
            throw new Exception("mismatch on played index in TestGame");
          }

          if (correctPlayedIndex != positionTest[0].PositionWithBoards.MiscInfo.InfoTraining.PlayedIndex)
          {
            throw new Exception("mismatch on played index in Test");
          }

          // Check one of the planes in the first and last positions.
          CheckBoard(in positionTest[0].PositionWithBoards, in positionCorrect[0].PositionWithBoards);
          CheckBoard(in positionTest[^1].PositionWithBoards, in positionCorrect[^1].PositionWithBoards);

          CheckBoard(testGame.PositionAtIndex(0), in positionCorrect[0].PositionWithBoards);
          CheckBoard(testGame.PositionAtIndex(positionTest.Length - 1), in positionCorrect[positionTest.Length - 1].PositionWithBoards);

          // Check policies.
          for (int j = 0; j < positionTest.Length; j++)
          {
            Span<float> policyTest = positionTest[j].Policies.ProbabilitiesSpan;
            Span<float> policyCorrect = positionCorrect[j].Policies.ProbabilitiesSpan;
            Span<float> policyTestGame = testGame.PolicyAtIndex(j).ProbabilitiesSpan;

            for (int i = 0; i < EncodedPolicyVector.POLICY_VECTOR_LENGTH; i++)
            {
              if (policyTest[i] != policyCorrect[i])
              {
                throw new Exception("Wrong policy (index 0) on EncodedTrainingPositionReaderTAREngine");
              }

              if (policyTestGame[i] != policyCorrect[i])
              {
                throw new Exception("Wrong policy (index 0) on EncodedTrainingPositionGameReader");
              }
            }
          }
        }
      }

      Console.WriteLine("verify " + gameCount + " " + posCount);
    }

  }
}